import functools
from decouple import config

import re
from typing import Callable, List

from loguru import logger
from telebot import types, TeleBot

from botrequests.bestdeal import get_bestdeal_hotels
from botrequests.highprice import get_highprice_hotels
from botrequests.lowprice import get_lowprice_hotels
from data.user_data import UserData
from exceptions.api_exception import ApiException
from infastructure.meta_date_options import MetaDateOptions
from models.hotel_result_model import HotelResultModel
from models.request_param_model import RequestParamModel

token = config('TOKEN')
bot = TeleBot(token, parse_mode=None)

logger.level(name='HISTORY', no=1, color=None, icon=None)
logger.add("debug.log", filter=lambda record: record["level"].name == "DEBUG",
           retention="10 days")
logger.add("info.log", filter=lambda record: record["level"].name == "INFO",
           retention="10 days")
logger.add("error.log", filter=lambda record: record["level"].name == "ERROR", rotation='5 MB',
           retention="10 days")
logger.add("history.log", filter=lambda record: record["level"].name == "HISTORY", format='{time:DD:MM:YYYY HH:mm:ss}%{message}',
           level='HISTORY', retention="10 days")


def user_data_decorator(func: Callable):
    user_data = UserData(dict())

    def wrapped(*args, **kwargs):
        result: List[HotelResultModel] = func(*args, **kwargs)
        message = args[0]
        if message.from_user.id not in user_data.users.keys():
            user_data.create_user(message)
        if result is not None:
            logger.log('HISTORY', 'üßê'.join([str(message.from_user.id), 'üòé'.join(
                ['*'.join(['–ù–∞–∑–≤–∞–Ω–∏–µ:' + hotel.name, '–ê–¥—Ä–µ—Å:' + hotel.address, '–¶–µ–Ω–∞:' + hotel.price, 'URL:' + hotel.url]) for hotel in result])]))

        return result

    return wrapped


def validator_with_regex(pattern: str, error_message: str):
    def validator_decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            message = args[0]
            request_param: RequestParamModel = args[1]
            is_acceptable = re.match(pattern, message.text)
            if is_acceptable is None:
                logger.error('VALIDATION. –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏')
                bot.send_message(message.from_user.id, error_message)
                message.text = request_param.previous_step[1]
                return request_param.previous_step[0](message, request_param)
            else:
                result = func(*args, **kwargs)
                return result

        return wrapper

    return validator_decorator


@bot.callback_query_handler(func=lambda call: call.data in ['/highprice', '/bestdeal', '/history', '/lowprice'])
def callback_worker(call):
    initial_step(message=call.message, command=call.data, from_user_id=call.from_user.id, is_from_call=True)


def initial_step(message, command: str, from_user_id: int, is_from_call=False):
    if command == "/highprice":
        choose_chain(message=message, command=command, from_user_id=from_user_id, is_from_call=is_from_call,
                     text='–î–æ—Ä–æ–≥–∏–µ –æ—Ç–µ–ª–∏ üëå')
    elif command == "/bestdeal":
        choose_chain(message=message, command=command, from_user_id=from_user_id, is_from_call=is_from_call,
                     text='–° —Ñ–∏–ª—å—Ç—Ä–æ–º üëå', is_detailed_survey=True)
    elif command == "/lowprice":
        choose_chain(message=message, command=command, from_user_id=from_user_id, is_from_call=is_from_call, text='–î–µ—à–µ–≤—ã–µ –æ—Ç–µ–ª–∏ üëå')
    else:
        get_history(message=message, is_from_call=is_from_call)


def get_history(message, is_from_call: bool = False, text: str = '–ò—Å—Ç–æ—Ä–∏—è üëå'):
    try:
        # –£–¥–∞–ª—è–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –≤—ã–±–æ—Ä–∞
        if is_from_call:
            bot.edit_message_text(text=text, message_id=message.message_id, chat_id=message.chat.id,
                                  reply_markup=None)
        with open('history.log', mode='r', encoding='utf-8') as file:
            data = file.readlines()
            counter = 0
            for string in data:
                time, message_with_id = string.split('%')
                user_id, items = message_with_id.split('üßê')
                items = [item.replace('*', '\n') for item in items.split('üòé')]
                if int(user_id) == message.chat.id:
                    counter += 1
                    bot.send_message(message.chat.id, ' '.join([str(counter), '–∑–∞–ø—Ä–æ—Å:']))
                    bot.send_message(message.chat.id, '–í—Ä–µ–º—è: ' + time)
                    bot.send_message(message.chat.id, '\n'.join(items), disable_web_page_preview=True)
        return True
    finally:
        bot.send_message(message.chat.id, '/help')


def choose_chain(message: types.Message, from_user_id: int, command: str, is_from_call: bool, text,
                 is_detailed_survey: bool = False):
    # –£–¥–∞–ª—è–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –≤—ã–±–æ—Ä–∞
    if is_from_call:
        bot.edit_message_text(text=text, message_id=message.message_id, chat_id=message.chat.id,
                              reply_markup=None)
    bot.send_message(from_user_id, '–í–≤–µ–¥–∏—Ç–µ –≥–æ—Ä–æ–¥, –≥–¥–µ –±—É–¥–µ—Ç –ø—Ä–æ–≤–æ–¥–∏—Ç—å—Å—è –ø–æ–∏—Å–∫:')
    request_param = RequestParamModel(is_detailed_survey=is_detailed_survey, command=command)
    request_param.previous_step = choose_chain, message.text
    bot.register_next_step_handler(message, get_city, request_param)


def get_city(message, request_param: RequestParamModel = None):
    request_param.city = message.text
    request_param.previous_step = get_city, message.text
    if request_param.is_detailed_survey:
        bot.send_message(message.from_user.id, '–í–≤–µ–¥–∏—Ç–µ –¥–∏–∞–ø–∞–∑–æ–Ω —Ü–µ–Ω —á–µ—Ä–µ–∑ –¥–µ—Ñ–∏—Å —Ä—É–±–ª—è—Ö. –ù–∞–ø—Ä–∏–º–µ—Ä, 0-10000:')
        bot.register_next_step_handler(message, get_range_price, request_param)
    else:
        bot.send_message(message.from_user.id, '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–≤–µ—Å—Ç–∏ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ:')
        bot.register_next_step_handler(message, get_hotels_count, request_param)


@validator_with_regex(r'\d+-\d+$', '–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã –≤–≤–µ–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω —Ü–∏—Ñ—Ä. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ')
def get_range_price(message, request_param: RequestParamModel = None):
    request_param.previous_step = get_range_price, message.text
    request_param.price_range = message.text.split('-')
    bot.send_message(message.from_user.id,
                     '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –∫–º. –ù–∞–ø—Ä–∏–º–µ—Ä, 3:')
    bot.register_next_step_handler(message, range_of_distance, request_param)


@validator_with_regex(r'\b\d+$', '–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã –≤–≤–µ–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ')
def range_of_distance(message, request_param: RequestParamModel = None):
    request_param.previous_step = range_of_distance, message.text
    request_param.max_distance = int(message.text)
    bot.send_message(message.from_user.id, '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–≤–µ—Å—Ç–∏ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ:')
    bot.register_next_step_handler(message, get_hotels_count, request_param)


@validator_with_regex(r'\b\d+$', '–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã –≤–≤–µ–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω —Ü–∏—Ñ—Ä. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ')
def get_hotels_count(message, request_param: RequestParamModel = None):
    request_param.previous_step = get_hotels_count, message.text
    request_param.hotels_count = message.text
    bot.send_message(message.from_user.id, '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∑–∞–≥—Ä—É–∑–∫–∏ –∏ –≤—ã–≤–æ–¥–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ—Ç–µ–ª—è (‚Äú–î–∞/–ù–µ—Ç‚Äù):')
    bot.register_next_step_handler(message, get_with_photos, request_param)


def get_with_photos(message, request_param: RequestParamModel = None):
    request_param.previous_step = get_with_photos, message.text
    if message.text.lower() == '–¥–∞':
        request_param.is_with_photos = True
        bot.send_message(message.from_user.id, '–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π:')
        bot.register_next_step_handler(message, get_photos_count, request_param)
    else:
        request_param.is_with_photos = False
        result_handler(message, request_param)


@validator_with_regex(r'\b\d+$', '–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ')
def get_photos_count(message, request_param: RequestParamModel):
    request_param.previous_step = get_photos_count, message.text
    request_param.photos_count = message.text
    result_handler(message, request_param)


@user_data_decorator
def result_handler(message, request_param: RequestParamModel = None) -> List:
    try:
        bot.send_message(message.from_user.id, '–≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –∫–∞–∫–æ–µ-—Ç–æ –≤—Ä–µ–º—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –ø–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ üëå')
        if request_param.command == '/lowprice':
            result = get_lowprice_hotels(request_param_model=request_param, meta_date=MetaDateOptions().meta_date)
        elif request_param.command == '/highprice':
            result = get_highprice_hotels(request_param_model=request_param, meta_date=MetaDateOptions().meta_date)
        elif request_param.command == '/bestdeal':
            result = get_bestdeal_hotels(request_param_model=request_param, meta_date=MetaDateOptions().meta_date)
        for hotel in result:
            bot.send_message(message.from_user.id, hotel, disable_web_page_preview=True)
            if hotel.photos_urls is not None:
                for photos_url in hotel.photos_urls:
                    bot.send_photo(message.from_user.id, photos_url)
        return result
    except ApiException as exception:
        error_code, description = exception.args[0].split(':')
        if error_code == 'EMPTY':
            bot.send_message(message.from_user.id, description)
        elif error_code == 'SEARCH':
            bot.send_message(message.from_user.id, description)
    except Exception:
        bot.send_message(message.from_user.id, '–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–æ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞')
    finally:
        start(message)


@bot.message_handler(content_types=['text'])
@logger.catch
def start(message):
    if message.text == '/hello_world':
        bot.send_message(message.from_user.id, "–ü—Ä–∏–≤–µ—Ç –º–∏—Ä")
    elif message.text in ['/highprice', '/bestdeal', '/lowprice']:
        initial_step(message=message, command=message.text, from_user_id=message.from_user.id)
    elif message.text == '/history':
        get_history(message=message)
    else:
        keyboard = generate_main_keyboard()
        bot.send_message(message.from_user.id, text='–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω–æ üëá:', reply_markup=keyboard)


def generate_main_keyboard():
    # –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
    keyboard = types.InlineKeyboardMarkup(row_width=2)  # –Ω–∞—à–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
    key_low_price = types.InlineKeyboardButton(text='–î–µ—à–µ–≤—ã–µ –æ—Ç–µ–ª–∏', callback_data='/lowprice')
    keyboard.add(key_low_price)  # –¥–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –≤ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    key_hight_price = types.InlineKeyboardButton(text='–î–æ—Ä–æ–≥–∏–µ –æ—Ç–µ–ª–∏', callback_data='/highprice')
    keyboard.add(key_hight_price)
    key_best_deal = types.InlineKeyboardButton(text='–° —Ñ–∏–ª—å—Ç—Ä–æ–º', callback_data='/bestdeal')
    keyboard.add(key_best_deal)
    key_history = types.InlineKeyboardButton(text='–ò—Å—Ç–æ—Ä–∏—è', callback_data='/history')
    keyboard.add(key_history)
    return keyboard


bot.polling(none_stop=True, interval=0)
